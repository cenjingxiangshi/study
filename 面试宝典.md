#### 小知识点

1. ​



#### git管理代码？？

#### 小程序与vue的区别和联系

#### vuex的使用

#### vue-resource

#### 做过的项目关于哪些内容

#### 网页适配用什么？除了媒体查询

#### webpack自定义往里加东西怎么加？

#### vue.use()的原理，为何会挂载插件可直接用

#### vue全家桶

​	Vue.js 是一个JavaScriptMVVM库，是一套构建用户界面的渐进式框架。它是以数据驱动和组件化的思想构建的，采用自底向上增量开发的设计。

React有状态管理库Flux、ReduxVue，相应的，Vue有vuex。

Vue有著名的全家桶系列，包含了vue-router（[http://router.vuejs.org](http://router.vuejs.org/)），vuex（[http://vuex.vuejs.org](http://vuex.vuejs.org/)）， vue-resource（<https://github.com/pagekit/vue-resource>）。再加上构建工具vue-cli，就是一个完整的vue项目的核心构成。

Vue两大核心思想，组件化和数据驱动，组件化就是将一个整体合理拆分为一个一个小块（组件），组件可重复使用，数据驱动是前端的未来发展方向，释放了对DOM的操作，让DOM随着数据的变化自然而然的变化（尤神原话），不必过多的关注DOM，只需要将数据组织好即可。

vue-resource的请求API是按照REST风格设计的，它提供了7种请求API： 
· get(url,[options]) 
· head(url,[options]) 
· delete(url,[options]) 
· jsonp(url,[options]) 
· post(url,[body], [options]) 
· put(url, [body],[options]) 
· patch(url,[body], [options])





**有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。** 





#### vue-resource 发送post请求:`{ emulateJSON: true }` 是必须有的，否则会存在跨域

```js

this.$http.post('http://127.0.0.1:8899/api/postcomment/'+ this.artid, {content: this.txtContent}, { emulateJSON: true }).then(res=>{
        if(res.status === 200){
          console.log(res.body.message)
        }
      })
```

#### router修改链接：

```js
//要链接到一个命名路由，可以给 router-link 的 to 属性传一个对象：

<router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link>
//这跟代码调用 router.push() 是一回事：

router.push({ name: 'user', params: { userId: 123 }})
//这两种方式都会把路由导航到 /user/123 路径。

//但是使用name时得在配置路由时加上name属性
{
  path: '/user',
  name: 'user',
  component: user
}
```



#### vuex的核心

state：data

getter：computed

Mutation：

```js

// 其他组件可以用commit触发mutation的demo事件
this.$store.commit('demo'，要传递给事件的参数pra)；

// 如下是mutation中的事件
mutations:{
    demo(state,pra){
        // 这里接受第一个参数是vuex的数据state，第二个是触发事件时传递的参数
    }
}
```



Action：

Module：

#### 购物车实现

**添加到购物车** 

1. 先将商品id及数量传递给vuex的store，
2. 购物车圆点动画用[transition](https://cn.vuejs.org/v2/api/#transition) 实现
3. 然后在store的mutations中设置方法将对象存储到localstorage中，
   1. 先取出localstorage中之前存入的对象
   2. 遍历一遍判断是否有相同的商品已存在，则直接增加此商品数量就行了
   3. 如果是购物车之前没有加过这个商品就直接push进去
   4. 将购物车的数据重新再写入localstorage中：`localStorage.setItem("carts", JSON.stringify(carts))` 
   5. 记得将vuex中的数据和localstorage中的数据进行同步

```js
import Vuex from "vuex"
import Vue from "vue"
Vue.use(Vuex);

export default new Vuex.Store({
  state: {
    carts:[]
  },
  mutations: {
    addToCart(state, goods) {
      // console.log(state, goods)
      //先去localStorage中获取之前存储好的购物车信息
      var carts = localStorage.getItem("carts");
      carts = carts ? JSON.parse(carts) : [];
      //遍历获取到的购物车数组，判断是否有和当前加进来的商品id相同的购物车数据
      var isExsit = false;
      carts.forEach(v => {
        //如果有，就将count合并，
        if (v.id == goods.id) {
          v.count += goods.count;
          isExsit = true;
        }
      })
      //如果没有就将新的购物车数据push数组中
      if (!isExsit) {
        carts.push(goods);
      }
      //将购物车数组数据重新存入到localstorage去
      localStorage.setItem("carts", JSON.stringify(carts));
      //将vuex中的数据和localStorage中的数据进行同步！！
      state.carts = carts;
    }
  }
})
```

**购物车页面** 

1. 先将localstorage的数据拿到，添加上是否被选择的属性，跟页面中的按钮双向绑定
2. 通过localstorage数据中id发送请求得到商品信息后渲染到页面
3. 减少商品数量：触发store里的方法，将id参数传递过去，减少localstorage中存储的数量
4. 增加商品数量和删除商品同上
5. 计算商品总数量：获取到被选中的所有商品数组，然后对数组中对象的数量求和
6. 计算总价格：筛选出被选中的商品，然后对每个商品计算总价后求和
7. 由于大多是直接对store的state做数据修改，所以一旦有数据被修改了，其他的组件数据也会相应做更新。

#### 兄弟组件之间的通信：

在简单的场景下，可以使用一个空的 Vue 实例作为中央事件总线：

```js
var bus = new Vue();

// 触发组件 A 中的事件
bus.$emit('id-selected', 1)


// 在组件 B 创建的钩子中监听事件
bus.$on('id-selected', function (id) {
  // ...
})
```

在复杂的情况下，我们应该考虑使用专门的[状态管理模式](https://cn.vuejs.org/v2/guide/state-management.html)。即[vuex](https://vuex.vuejs.org/zh-cn/getting-started.html) 

#### require 和 import

require的使用非常简单，它相当于module.exports的传送门，module.exports后面的内容是什么，require的结果就是什么，对象、数字、字符串、函数……再把require的结果赋值给某个变量，相当于把require和module.exports进行平行空间的位置重叠。

而且require理论上可以运用在代码的任何地方，甚至不需要赋值给某个变量之后再使用，比如：

require('./a')();// a模块是一个函数，立即执行a模块函数var data = require('./a').data;// a模块导出的是一个对象var a = require('./a')[0];// a模块导出的是一个数组

你在使用时，完全可以忽略模块化这个概念来使用require，仅仅把它当做一个node内置的全局函数，它的参数甚至可以是表达式：

require(process.cwd() + '/a');

但是import则不同，它是编译时的（require是运行时的），它必须放在文件开头，而且使用格式也是确定的，不容置疑。它不会将整个模块运行后赋值给某个变量，而是只选择import的接口进行编译，这样在性能上比require好很多。

从理解上，require是赋值过程，import是解构过程，当然，require也可以将结果解构赋值给一组变量，但是import在遇到default时，和require则完全不同： `var $ = require('jquery');` 和 `import $ from 'jquery'` 是完全不同的两种概念。



#### 前端开发遇到的难题

我年中的时候在做这个信贷产品，这个产品的目的是管理用户的，其中有一个（什么模块），为了实现（什么功能），用到了（什么技术），但是（遇到了什么挑战／难点／bug），我通过（怎样的手段）定位问题所在，问题出现的原因是（简要的点到技术点的描述），我在（至少两个资料来源）上找到了参考，最后基于（怎样的决策标准）决定采用（何种解决方法），运用了（哪种技术），最后成功解决了问题／实现了功能，结果是这个产品／程序（对用户，系统，性能，可用性，资源等产生了何种正面的影响）。下一步，我认为我应该研究（何种更先进的方式），进一步（怎样让产品／程序做得更好）。



以我目前的经验看来，CSS界中position+overflow，vertical-align+line-height+baseline实乃N大最恶心问题之二。



#### 黑洞投资下的子公司

实地地产和黑洞投资合作，客户购买了实地地产的房子，可以向握手分期申请家装分期，业主闪贷就是

家装分期就是业主向握手申请贷款，3期，6期到24期等，合作的家装公司提供服务，然后业主分期还款；必须是实地业主，有业主数据库；用手机号和身份证号匹配；

业主闪贷：蚂蚁借呗类似，仅对业主开放用户注册的信息会走风控系统，得到一个评分，风控接口是百融金服的，百融金服对接了其他信用部门的系统，用户信息跑到百融后会得到一个评分，假设评分是70,50以下是不给额度，50-60是一万的额度，一分涨一100，最高是20w的额度，再有一个接口是根据评分返回额度；

宅抵贷：线下申请，页面只是展示信息，电话点击后呼叫是调用的APPcan的api

打包成APP用的appcan

其实还有一个模块是关于跟其他机构合作，提供借贷服务